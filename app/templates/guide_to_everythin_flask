


((((# Guide for activating virtual enviroments, python:))))

virtualenv and pip_test_env
. pip_test_env/bin/activate
pip_test_env\Scripts\activate.bat
 
 ((((# Guide for deactivating virtual enviroments, python:))))

deactivate

((((# Guide for creating a new virtual enviroment and installing flask on it))))

sudo easy_install virtualenv or sudo pip install virtualenv
sudo apt-get install python-virtualenv
mkdir myproject
cd myproject
virtualenv venv
New python executable in venv/bin/python
you should get something like this: Installing distribute............done.
. venv/bin/activate or venv\scripts\activate
pip install Flask
sudo pip install Flask
this command is used to install (pip) > easy_install pip

((((#Guide for launching flask app on my local computer))))

you should already have code for the app already existing and must be stable ex:

"from flask import Flask
app = Flask(__name__)

@app.route('/')
def hello_world():
    return 'Hello World!'

if __name__ == '__main__':
    app.run()"
when you run the command in the terminal you should get something like this:
$ python hello.py
 * Running on http://127.0.0.1:5000/
 
 So what did that code do?

First we imported the Flask class. An instance of this class will be our WSGI application.
Next we create an instance of this class. The first argument is the name of the application’s module or package. If you are using a single module (as in this example), you should use __name__ because depending on if it’s started as application or imported as module the name will be different ('__main__' versus the actual import name). This is needed so that Flask knows where to look for templates, static files, and so on. For more information have a look at the Flask documentation.
We then use the route() decorator to tell Flask what URL should trigger our function.
The function is given a name which is also used to generate URLs for that particular function, and returns the message we want to display in the user’s browser.
Finally we use the run() function to run the local server with our application. The if __name__ == '__main__': makes sure the server only runs if the script is executed directly from the Python interpreter and not used as an imported module.
To stop the server, hit control-C.

Routing
Modern web applications have beautiful URLs. This helps people remember the URLs, which is especially handy for applications that are used from mobile devices with slower network connections. If the user can directly go to the desired page without having to hit the index page it is more likely they will like the page and come back next time.

As you have seen above, the route() decorator is used to bind a function to a URL. Here are some basic examples:

@app.route('/')
def index():
    return 'Index Page'

@app.route('/hello')
def hello():
    return 'Hello World'
But there is more to it! You can make certain parts of the URL dynamic and attach multiple rules to a function.


(((#Guide for using the browser to view the flask app running locally)))

